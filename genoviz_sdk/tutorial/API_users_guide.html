    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
            "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
  <head>
    <title> GenoViz SDK - API User's Guide </title>
    <style type="text/css"><!--
body {
        margin-top: 12pt;
        margin-left: 10%;
        margin-right: 5%;
        background: #ffe
}
h1, h2, h3, h4, h5, h6 {
        font-family: helvetica, sans-serif
}
 -->
    </style>
  </head>
<body>
    
<h1> API User's Guide </h1>

    <img src="../images/affymetrix_logo.gif"
      alt="Affymetrix, Inc."
      align="right"
      >

    <p>
      The Affymetrix GenoViz Software Development Kit provides
      Java components for bioinformatics data visualization.  These
      components are designed to be integrated into larger software
      systems via extensive application programming interfaces (APIs).
    </p>
    
    <h2> Widgets </h2>

    <p>
      To write Java programs (Applets or Applications) using the
      GenoViz Software Development Kit you will need some
      background.
    </p>

    <p>
      The GenoViz SDK provides many classes distributed
      among several packages. 
      But most of your work will be with our "widgets".  
      The GenoViz widgets implement the interface <code>
      com.affymetrix.genoviz.widget.NeoWidgetI</code>.
    </p>

    <p>
      There are two classes that implement the NeoWidgetI interface.
      NeoWidget and NeoContainerWidget.
    </p>
      
    <p>
      There is one subclass of NeoWidget: NeoMap.
    </p>

    <p>
      There are four subclasses of NeoContainerWidget: NeoAssembler, 
      NeoSeq, NeoQualler, NeoTracer.
    </p>
    
    <p>
      Examples of these classes can be found in 
      the <a href="./index.html">Tutorial</a>.
    </p>

    
    <h2> Views, Scenes, and Glyphs </h2>

    <p>
        A NeoMap has a view of a scene containing glyphs.
    </p>

    <p>
      A glyph can be in only one scene.
    </p>

    <p>
      A scene can have multiple viewers;  i.e.  multiple viewers can
      view a single scene.
    </p>

    <p>
      A NeoMap can have only one view.  So multiple views of a scene
      are in multiple NeoMaps.
    </p>

    <h2> Panning (Scrolling) and Scaling (Zooming) </h2>
    
    <p>
      A scene can be positioned in a view by scrolling.
    </p>

    <p>
      A scene can be scaled in a view by zooming.
    </p>

    <h2> Adding Glyphs to a Map </h2>

    <p>
      You add glyphs to a map in two steps.  First you "configure" the
      map.  Then you add an "item" to the map.
    </p>

    <p>
      The configuration step actually creates and configures a factory
      for glyphs.  When an item is added to the map the map hands the
      start and end parameters to the factory it just configured.  A
      new glyph is created and will be displayed the next time the map
      is updated.
    </p>

    <p>
      You can add several items after each configuration.  All such
      items will have the same appearance and will appear at the same
      offset from the axis.  However, each one can appear at different
      places along the axis.
    </p>


    <p>
      The configuration string consists of one or more pairs of the
      form <code>-name value</code>.
    </p>


    <p>
      One of the attribues passed to <code>map.configure()</code> is a
      type of glyph.  The com.affymetrix.genoviz.glyph package contains
      different types of glyphs.  The value of the -type attribute
      configured should match one of those glyphs.
      If you have created your own glyphs,
      you can use it bye supplying the fully qualified class name
      for the -type attribute.
    </p>

    <h3> Glyphs Within Glyphs </h3>

    <p>
      A map's addItem method also returns the glyph that was created.
      This can in turn be handed to another version of addItem() In
      this way you can create a hierarchy of glyphs.
    </p>

    <h3> Glyph Factories </h3>

    <p>        
      com.affymetrix.genoviz.bioviews has a MapGlyphFactory class.
    </p>

    <p>
      Each MapGlyphFactory can create only one kind of Glyph.  So for
      each kind of glyph, you will want to create and configure a new
      MapGlyphFactory.  Then when it's time to create a glyph, you
      give the factory a start and end and get back the finished
      glyph.
    </p>

    <p class=q>
      This is all done through the map.  You use the
      <code>map.addFactory()</code> method.  This method takes a
      string just like the one in <code>map.configure()</code>.  An
      additional attribute in the string is the factory's name.
      e.g. <code>-name fred</code>.  The map will create a factory,
      configure it with the string you passed, and store it in a
      collection of such factories.  You can then use another
      variation of <code>map.addItem()</code> passing it the name of
      one of the factories you added.  e.g. <code>map.addItem("fred",
      1000, 2000)</code>.
    </p>
    

    <h2> Data Models and Data Adapters </h2>

    <p>
      You may want several different types of glyphs and many glyphs
      of each type.  e.g. many features of different types on a
      nucleotide sequence.  You might want to create a data model for
      each type.  Then you would need a way to adapt each data model
      to the map so that a particular type of glyph is associated with
      that data model.  Then it would be a simple matter to add glyphs
      representing instances of the data model one at a time to the
      map.
    </p>

    <h3> Data Adapters </h3>

    <p>
        You add a data adapter to a map.  You can then add data models
        directly to the map using the map's <code>addData()</code>
        method.
    </p>

    <p>
      A problem arrises when there is more than one appropriate data
      adapter.  Each adapter has to know how to use a model to create
      a Glyph.  An adapter can use a MapGlyphFactory to produce the
      Glyph.
    </p>

    <h2> Parsers </h2>

    <p>
      What is needed now is a way to convert an outside format to an
      internal data model.
    </p>

    <h2> Another Approach </h2>
    
    <p>
      There is another way to handle the problem of loading a widget
      with data obtained over the net.  A widget need not know
      anything about a data model.
    </p>

    <h3> Content Handlers </h3>

    <p>
        These are java.net.ContentHandler We use them to get data from
        a URL and convert it to a data model.  They use content
        parsers to do the actual parsing Their getContent() method
        will return the data model.
    </p>
      
    <h3> Content Parsers </h3>

    <p>
      These do the actual parsing.  They implement the
      com.affymetrix.genoviz.ContentParser interface.  Their
      <code>import()</code> method builds and returns a data model.
      They also have an export method.  So they handle translation
      between a particular data model and an outside format.
    </p>

    <h3> Data Models </h3>

    <p>
      These can be any object.  They will contain the data to be shown
      in a widget.
    </p>

    <h3> Data Adapters </h3>

    <p>
      These adapt data models to widgets.  They implement the
      com.affymetrix.genoviz.DataAdapter interface.  They relieve the widget
      of the burden of knowing about different data models.  They are
      found in the com.affymetrix.genoviz.widget package.
    </p>

    <p> </p>

    <hr>
    <h3><a href="../index.html">GenoViz SDK Overview</a></h3>
    <hr>
    
  </body>
</html>
