/**
*   Copyright (c) 1998-2005 Affymetrix, Inc.
*    
*   Licensed under the Common Public License, Version 1.0 (the "License").
*   A copy of the license must be included with any distribution of
*   this source code.
*   Distributions from Affymetrix, Inc., place this in the
*   IGB_LICENSE.html file.  
*
*   The license is also available at
*   http://www.opensource.org/licenses/cpl.php
*/

package com.affymetrix.genoviz.pseudoswing;

import java.awt.*;
import java.util.*;

/**
 * Utility methods to allow threads wishing to manipulate GenoViz widgets
 * to be run on the event dispatch thread.
 * Therefore they can be run synchronously with AWT events / paints.
 *
 * <p> Inspired by the invokeLater() and invokeAndWait() design in JFC SwingUtilities.
 */
public class ThreadUtilities  {

  /**
   *  Queue a Runnable object to be run() on the event dispatch thread,
   *     and return immediately (current thread does not block).
   *  Note that for now this method assumes that current Thread is _not_ the
   *  event dispatch thread!
   */
  public static void invokeLater(Runnable the_runnable) {
    postRunnable(the_runnable, null);
  }

  /**
   *  Queue a Runnable object to be run() on the event dispatch thread,
   *     and block the current thread until the Runnable.run() call returns.
   *  Note that for now this method assumes that current Thread is _not_ the
   *  event dispatch thread!
   */
  public static void invokeAndWait(Runnable the_runnable) throws Exception {
    Exception e = null;
    Object lock = new Object();  // lock object is just generic Object instance
    synchronized(lock) {
      e = postRunnable(the_runnable, lock);
      lock.wait();
    }
    if (e != null) {
      throw e;
    }
  }

  /**
   * Wraps an event around a Runnable and posts to the AWT event queue.
   * When the event is dispatched it in turn calls Runnable.run().
   * <em>If</em> lock exists <em>and</em>
   *      the Runnable generates an Exception when run()  <em>and</em>
   *      current thread is blocked (usually because of wait(lock) in
   *           calling method invokeAndWait())
   * <em>then</em> return the Exception generated by the Runnable
   * <em>else</em> return null.
   */
  static Exception postRunnable(Runnable the_runnable, Object lock)  {
    WrappedRunnableEvent event = new WrappedRunnableEvent(the_runnable, lock);
    postEventQueueCanvasEvent(event);
    return event.getException();
  }

  /**
   * Synchronized entry point to the applet support for AWT System
   * event queue access.  This method adds the event to the appropriate
   * runnable canvas's queue and then has the canvas repaint().  Note
   * that by the time the event dispatching thread gets to handling
   * the repaint() (by calling EventQueueCanvas.update()), many runnable
   * events may have been queued up.
   */
  static synchronized void postEventQueueCanvasEvent(WrappedRunnableEvent e) {
    EventQueueCanvas eventcan = EventQueueCanvas.getFirstVisible();
    if (eventcan == null) {
      // can't proceed -- no event queue canvas found
      //   but, need to make sure no locks remain...
      System.err.println("couldn't find a EventQueueCanvas to queue event!");
      if (e.lock != null) { e.lock.notify(); }
      return;
    }
    eventcan.addWrappedRunnableEvent(e);
    eventcan.repaint();
  }

  /**
   * Associate a EventQueueCanvas and a Container to enable later queuing of
   *  WrappedRunnableEvents on event dispatching thread via
   *  invokeLater() and invokeAndWait()
   */
  public static synchronized Canvas addEventQueueCanvas(Container cont)   {
    EventQueueCanvas rc = new EventQueueCanvas(cont);
    cont.add(rc);
    return rc;
  }

  /** remove EventQueueCanvas from the Container and clean up */
  public static synchronized void removeEventQueueCanvas(Container cont) {
    EventQueueCanvas.remove(cont);
  }

}
