/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * GeneralLoadView.java
 *
 * Created on Aug 24, 2011, 11:49:48 AM
 */
package com.affymetrix.igb.view.load;

import static com.affymetrix.igb.IGBConstants.BUNDLE;


import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingWorker;

import com.affymetrix.genometryImpl.SeqSpan;
import com.affymetrix.genometryImpl.util.LoadUtils.LoadStrategy;
import com.affymetrix.genometryImpl.util.LoadUtils.ServerType;
import com.affymetrix.genometryImpl.GenometryModel;
import com.affymetrix.genometryImpl.BioSeq;
import com.affymetrix.genometryImpl.general.GenericFeature;
import com.affymetrix.genometryImpl.general.GenericVersion;
import com.affymetrix.genometryImpl.span.SimpleSeqSpan;
import com.affymetrix.genometryImpl.symloader.SymLoaderInst;
import com.affymetrix.genometryImpl.thread.CThreadWorker;
import com.affymetrix.genometryImpl.util.ErrorHandler;
import com.affymetrix.genometryImpl.util.ThreadUtils;
import com.affymetrix.genoviz.swing.MenuUtil;
import com.affymetrix.genoviz.swing.recordplayback.JRPButton;

import com.affymetrix.igb.osgi.service.IGBService;
import com.affymetrix.igb.osgi.service.IGBTabPanel;
import com.affymetrix.igb.prefs.PreferencesPanel;
import com.affymetrix.igb.view.DataLoadPrefsView;
import com.affymetrix.igb.view.SeqMapView;
import com.affymetrix.igb.Application;
import com.affymetrix.igb.IGBConstants;
import com.affymetrix.igb.action.LoadSequence;
import com.affymetrix.igb.featureloader.QuickLoad;
import com.affymetrix.igb.util.IGBUtils;
import com.affymetrix.igb.view.SeqGroupView;
import com.affymetrix.igb.view.TrackView;
import java.awt.Font;
import javax.swing.table.TableCellRenderer;

/**
 *
 * @author lorainelab
 */
public class GeneralLoadView extends IGBTabPanel {

	private static final long serialVersionUID = 1L;
	private static final int TAB_POSITION = Integer.MIN_VALUE;
	private static final boolean DEBUG_EVENTS = false;
	private static final GenometryModel gmodel = GenometryModel.getGenometryModel();
	public static int TAB_DATALOAD_PREFS = -1;
	private static final String LOAD = IGBConstants.BUNDLE.getString("load");
	private AbstractAction refreshDataAction;
	private static SeqMapView gviewer;
	private static LoadModeDataTableModel loadModeDataTableModel;
	static JScrollPane featuresTableScrollPane;
	private FeatureTreeView feature_tree_view;
	private static GeneralLoadView singleton;

	public static void init(IGBService _igbService) {
		singleton = new GeneralLoadView(_igbService);
	}

	public static synchronized GeneralLoadView getLoadView() {
		return singleton;
	}

	/** Creates new form GeneralLoadView */
	private GeneralLoadView(IGBService _igbService) {
		super(_igbService, BUNDLE.getString("dataAccessTab"), BUNDLE.getString("dataAccessTab"), true, TAB_POSITION);
		gviewer = Application.getSingleton().getMapView();
		initComponents();

		GeneralLoadUtils.loadServerMapping();

		final PreferencesPanel pp = PreferencesPanel.getSingleton();
		TAB_DATALOAD_PREFS = pp.addPrefEditorComponent(new DataLoadPrefsView());
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        feature_tree_view = new FeatureTreeView();
        tree = feature_tree_view.getTree();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        loadModeDataTableModel = new LoadModeDataTableModel(this);
        loadedTracksTable = new JTableX(loadModeDataTableModel);
        partial_residuesB = new JRPButton("DataAccess_sequenceInView", LoadSequence.getPartialAction());
        this.refreshDataAction = gviewer.getRefreshDataAction();
        refresh_dataB = new JRPButton("DataAccess_refreshData", refreshDataAction);
        all_residuesB = new JRPButton("DataAccess_allSequence", LoadSequence.getWholeAction());

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose Data Sources and Data Sets"));

        tree.setBorder(javax.swing.BorderFactory.createTitledBorder(""));
        jScrollPane1.setViewportView(tree);

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 259, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 251, Short.MAX_VALUE)
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Data Management Table"));

        loadedTracksTable.setModel(loadModeDataTableModel);
        loadedTracksTable.setRowHeight(20);    // TODO: better than the default value of 16, but still not perfect.
        // Handle sizing of the columns
        loadedTracksTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);   // Allow columns to be resized
        jScrollPane2.setViewportView(loadedTracksTable);

        partial_residuesB.setToolTipText(MessageFormat.format(LOAD, IGBConstants.BUNDLE.getString("partialNucleotideSequence")));
        partial_residuesB.setMaximumSize(partial_residuesB.getPreferredSize());
        partial_residuesB.setEnabled(false);
        partial_residuesB.setFont(new java.awt.Font("Serif", 1, 14));
        partial_residuesB.setIcon(IGBUtils.getIcon("dna.gif"));
        partial_residuesB.setText("Load Sequence In View");

        refresh_dataB.setToolTipText(BUNDLE.getString("refreshDataTip"));
        refresh_dataB.setMaximumSize(refresh_dataB.getPreferredSize());
        refreshDataAction.setEnabled(false);
        refresh_dataB.setFont(new java.awt.Font("Serif", 1, 14));
        refresh_dataB.setIcon(MenuUtil.getIcon("toolbarButtonGraphics/general/Refresh16.gif"));
        refresh_dataB.setText("Load Data");

        all_residuesB.setFont(new java.awt.Font("Serif", 1, 14));
        all_residuesB.setText("Load All Sequence");

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel2Layout.createSequentialGroup()
                .add(all_residuesB, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(partial_residuesB, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(refresh_dataB, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE))
            .add(jScrollPane2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 612, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                .add(jScrollPane2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 213, Short.MAX_VALUE)
                .add(9, 9, 9)
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.CENTER)
                    .add(all_residuesB)
                    .add(partial_residuesB)
                    .add(refresh_dataB)))
        );

        all_residuesB.setToolTipText(MessageFormat.format(LOAD, IGBConstants.BUNDLE.getString("nucleotideSequence")));
        all_residuesB.setMaximumSize(all_residuesB.getPreferredSize());
        all_residuesB.setIcon(IGBUtils.getIcon("dna.gif"));
        all_residuesB.setEnabled(false);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton all_residuesB;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTable loadedTracksTable;
    private javax.swing.JButton partial_residuesB;
    private javax.swing.JButton refresh_dataB;
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables

	public javax.swing.JButton getPartial_residuesButton() {
		return partial_residuesB;
	}

	public javax.swing.JButton getAll_ResiduesButton() {
		return all_residuesB;
	}

	public AbstractAction getRefreshAction() {
		return refreshDataAction;
	}

	public void initVersion(String versionName) {
		igbService.addNotLockedUpMsg("Loading chromosomes for " + versionName);
		try {
			GeneralLoadUtils.initVersionAndSeq(versionName); // Make sure this genome versionName's feature names are initialized.
		} finally {
			igbService.removeNotLockedUpMsg("Loading chromosomes for " + versionName);
		}
	}

	/**
	 * Handles clicking of partial residue, all residue, and refresh data buttons.
	 * @param evt
	 */
	public void loadResidues(AbstractAction action) {
		Object src = null;

		if (action.equals(partial_residuesB.getAction())) {
			src = partial_residuesB;
		} else if (action.equals(all_residuesB.getAction())) {
			src = all_residuesB;
		}

		if (src != partial_residuesB && src != all_residuesB) {
			return;
		}

		final String genomeVersionName = (String) SeqGroupView.getInstance().getVersionCB().getSelectedItem();
		final BioSeq seq = gmodel.getSelectedSeq();
		final boolean partial = src == partial_residuesB;

		SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {

			public Boolean doInBackground() {
				return loadResidues(genomeVersionName, seq, gviewer.getVisibleSpan(), partial, false, true);
			}

			@Override
			public void done() {
				try {
					if (get()) {
						gviewer.setAnnotatedSeq(seq, true, true, true);
					}
				} catch (Exception ex) {
					Logger.getLogger(GeneralLoadView.class.getName()).log(Level.SEVERE, null, ex);
				} finally {
//					igbService.removeNotLockedUpMsg("Loading residues for " + seq.getID());
				}
			}
		};

		// Use a SwingWorker to avoid locking up the GUI.
		ThreadUtils.getPrimaryExecutor(src).execute(worker);
	}

	public boolean loadResiduesInView(boolean tryFull) {
		final String genomeVersionName = (String) SeqGroupView.getInstance().getVersionCB().getSelectedItem();
		SeqSpan visibleSpan = gviewer.getVisibleSpan();
		return loadResidues(genomeVersionName, visibleSpan.getBioSeq(), visibleSpan, true, tryFull, false);
	}

	public boolean loadResidues(SeqSpan span, boolean tryFull) {
		final String genomeVersionName = (String) SeqGroupView.getInstance().getVersionCB().getSelectedItem();
		if (!span.isForward()) {
			span = new SimpleSeqSpan(span.getMin(), span.getMax(), span.getBioSeq());
		}
		return loadResidues(genomeVersionName, span.getBioSeq(), span, true, tryFull, false);
	}

	public boolean loadResidues(final String genomeVersionName, final BioSeq seq,
			final SeqSpan viewspan, final boolean partial, final boolean tryFull, final boolean show_error_panel) {
		try {
			if (partial) {
				if (!GeneralLoadUtils.loadResidues(genomeVersionName, seq, viewspan.getMin(), viewspan.getMax(), viewspan)) {
					if (!tryFull) {
						if (show_error_panel) {
							ErrorHandler.errorPanel("Couldn't load partial sequence", "Couldn't locate the partial sequence.  Try loading the full sequence.");
						}
						Logger.getLogger(GeneralLoadView.class.getName()).log(Level.WARNING, "Unable to load partial sequence");
						return false;
					} else {
						if (!GeneralLoadUtils.loadResidues(genomeVersionName, seq, 0, seq.getLength(), null)) {
							if (show_error_panel) {
								ErrorHandler.errorPanel("Couldn't load partial or full sequence", "Couldn't locate the sequence.");
							}
							Logger.getLogger(GeneralLoadView.class.getName()).log(Level.WARNING,
									"Couldn't load partial or full sequence. Couldn't locate the sequence.");
							return false;
						}
					}
				}
			} else {
				if (!GeneralLoadUtils.loadResidues(genomeVersionName, seq, 0, seq.getLength(), null)) {
					if (show_error_panel) {
						ErrorHandler.errorPanel("Couldn't load full sequence", "Couldn't locate the sequence.");
					}
					Logger.getLogger(GeneralLoadView.class.getName()).log(Level.WARNING,
							"Couldn't load full sequence. Couldn't locate the sequence.");
					return false;
				}
			}
		} catch (Exception ex) {
			ex.printStackTrace();
			return false;
		}

		return true;
	}

	/**
	 * Load any data that's marked for visible range.
	 */
	public void loadVisibleFeatures() {
		if (DEBUG_EVENTS) {
			SeqSpan request_span = gviewer.getVisibleSpan();
			System.out.println("Visible load request span: " + request_span.getBioSeq() + ":" + request_span.getStart() + "-" + request_span.getEnd());
		}
		List<LoadStrategy> loadStrategies = new ArrayList<LoadStrategy>();
		loadStrategies.add(LoadStrategy.AUTOLOAD);
		loadStrategies.add(LoadStrategy.VISIBLE);
		loadStrategies.add(LoadStrategy.CHROMOSOME);
		loadFeatures(loadStrategies, null);
	}

	/**
	 * Load any features that have a autoload strategy and haven't already been loaded.
	 */
	public static void loadAutoLoadFeatures() {
		List<LoadStrategy> loadStrategies = new ArrayList<LoadStrategy>();
		loadStrategies.add(LoadStrategy.AUTOLOAD);
		loadFeatures(loadStrategies, null);
		GeneralLoadUtils.bufferDataForAutoload();
	}

	/**
	 * Load any features that have a whole strategy and haven't already been loaded.
	 * @param versionName
	 */
	public static void loadWholeRangeFeatures(ServerType serverType) {
		List<LoadStrategy> loadStrategies = new ArrayList<LoadStrategy>();
		loadStrategies.add(LoadStrategy.GENOME);
		loadFeatures(loadStrategies, serverType);
	}

	static void loadFeatures(List<LoadStrategy> loadStrategies, ServerType serverType) {
		for (GenericFeature gFeature : GeneralLoadUtils.getSelectedVersionFeatures()) {
			loadFeature(loadStrategies, gFeature, serverType);
		}
	}

	static void loadFeature(List<LoadStrategy> loadStrategies, GenericFeature gFeature, ServerType serverType) {
		if (!loadStrategies.contains(gFeature.getLoadStrategy())) {
			return;
		}

		if (serverType != null && gFeature.gVersion.gServer.serverType != serverType) {
			return;
		}

		GeneralLoadUtils.loadAndDisplayAnnotations(gFeature);
	}

	public static void AutoloadQuickloadFeature() {
		for (GenericFeature gFeature : GeneralLoadUtils.getSelectedVersionFeatures()) {
			if (gFeature.getLoadStrategy() != LoadStrategy.GENOME
					|| gFeature.gVersion.gServer.serverType != ServerType.QuickLoad) {
				continue;
			}

			//If Loading whole genome for unoptimized file then load everything at once.
			if (((QuickLoad) gFeature.symL).getSymLoader() instanceof SymLoaderInst) {
				((QuickLoad) gFeature.symL).loadAllSymmetriesThread(gFeature);
			} else {
				GeneralLoadUtils.iterateSeqList(gFeature);
			}
		}
	}

	public void refreshTreeView() {

		ThreadUtils.runOnEventQueue(new Runnable() {

			public void run() {
				final List<GenericFeature> features = GeneralLoadUtils.getSelectedVersionFeatures();
				if (features == null || features.isEmpty()) {
					loadModeDataTableModel.clearFeatures();
				}
				feature_tree_view.initOrRefreshTree(features);
			}
		});
	}

	/**
	 * Create the table with the list of features and their status.
	 */
	public List<GenericFeature> createFeaturesTable() {
		String versionName = (String) SeqGroupView.getInstance().getVersionCB().getSelectedItem();
		final List<GenericFeature> features = GeneralLoadUtils.getSelectedVersionFeatures();
		if (DEBUG_EVENTS) {
			BioSeq curSeq = gmodel.getSelectedSeq();
			System.out.println("Creating new table with chrom " + (curSeq == null ? null : curSeq.getID()));
			System.out.println("features for " + versionName + ": " + features.toString());
		}

		int maxFeatureNameLength = 1;
		for (GenericFeature feature : features) {
			maxFeatureNameLength = Math.max(maxFeatureNameLength, feature.featureName.length());
		}
		final int finalMaxFeatureNameLength = maxFeatureNameLength;	// necessary for threading

		final List<GenericFeature> visibleFeatures = LoadModeDataTableModel.getVisibleFeatures(features);

		ThreadUtils.runOnEventQueue(new Runnable() {

			public void run() {
				loadModeDataTableModel.createVirtualFeatures(visibleFeatures);

				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.REFRESH_FEATURE_COLUMN).setPreferredWidth(20);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.REFRESH_FEATURE_COLUMN).setMinWidth(20);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.REFRESH_FEATURE_COLUMN).setMaxWidth(20);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.HIDE_FEATURE_COLUMN).setPreferredWidth(24);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.HIDE_FEATURE_COLUMN).setMinWidth(24);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.HIDE_FEATURE_COLUMN).setMaxWidth(24);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.LOAD_STRATEGY_COLUMN).setPreferredWidth(135);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.LOAD_STRATEGY_COLUMN).setMinWidth(110);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.LOAD_STRATEGY_COLUMN).setMaxWidth(150);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FEATURE_NAME_COLUMN).setPreferredWidth(finalMaxFeatureNameLength);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FEATURE_NAME_COLUMN).setMinWidth(110);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FEATURE_NAME_COLUMN).setMaxWidth(200);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.TRACK_NAME_COLUMN).setPreferredWidth(160);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.DELETE_FEATURE_COLUMN).setPreferredWidth(15);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.DELETE_FEATURE_COLUMN).setMinWidth(15);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.DELETE_FEATURE_COLUMN).setMaxWidth(15);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.BACKGROUND_COLUMN).setPreferredWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.BACKGROUND_COLUMN).setMinWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.BACKGROUND_COLUMN).setMaxWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FOREGROUND_COLUMN).setPreferredWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FOREGROUND_COLUMN).setMinWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.FOREGROUND_COLUMN).setMaxWidth(25);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.INFO_FEATURE_COLUMN).setPreferredWidth(20);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.INFO_FEATURE_COLUMN).setMinWidth(20);
				loadedTracksTable.getColumnModel().getColumn(LoadModeDataTableModel.INFO_FEATURE_COLUMN).setMaxWidth(20);

				loadedTracksTable.getTableHeader().setReorderingAllowed(false);
				TableCellRenderer renderer = loadedTracksTable.getTableHeader().getDefaultRenderer();
				JLabel label = (JLabel) renderer;
				label.setHorizontalAlignment(JLabel.CENTER);
				loadedTracksTable.getTableHeader().setDefaultRenderer(renderer);

				Font f = new Font("Serif", Font.BOLD, 12);
				loadedTracksTable.getTableHeader().setFont(f);
				loadedTracksTable.setRowSelectionAllowed(false);
				loadedTracksTable.setCellSelectionEnabled(true);

				// Don't enable combo box for full genome sequence
				// Enabling of combo box for local files with unknown chromosomes happens in setComboBoxEditors()
				LoadModeTable.setComboBoxEditors((JTableX) loadedTracksTable, !GeneralLoadView.IsGenomeSequence());
			}
		});

		disableButtonsIfNecessary();
		changeVisibleDataButtonIfNecessary(features);	// might have been disabled when switching to another chromosome or genome.
		return features;
	}

	/**
	 * Check if it is necessary to disable buttons.
	 * @return
	 */
	public static boolean getIsDisableNecessary() {
		boolean enabled = !IsGenomeSequence();
		if (enabled) {
			BioSeq curSeq = gmodel.getSelectedSeq();
			enabled = curSeq.getSeqGroup() != null;	// Don't allow a null sequence group either.
			if (enabled) {		// Don't allow buttons for an "unknown" versionName
				Set<GenericVersion> gVersions = curSeq.getSeqGroup().getEnabledVersions();
				enabled = (!gVersions.isEmpty());
			}
		}
		return enabled;
	}

	/**
	 * Don't allow buttons to be used if they're not valid.
	 */
	private void disableButtonsIfNecessary() {
		// Don't allow buttons for a full genome sequence
		setAllButtons(getIsDisableNecessary());
	}

	public void disableAllButtons() {
		setAllButtons(false);
	}

	private void setAllButtons(final boolean enabled) {
		ThreadUtils.runOnEventQueue(new Runnable() {

			public void run() {
				all_residuesB.setEnabled(enabled);
				partial_residuesB.setEnabled(enabled);
				refreshDataAction.setEnabled(enabled);
			}
		});
	}

	/**
	 * Accessor method.
	 * See if we need to enable/disable the refresh_dataB button
	 * by looking at the features' load strategies.
	 */
	void changeVisibleDataButtonIfNecessary(List<GenericFeature> features) {
		if (IsGenomeSequence()) {
			return;
			// Currently not enabling this button for the full sequence.
		}
		boolean enabled = false;
		for (GenericFeature gFeature : features) {
			if (gFeature.getLoadStrategy() != LoadStrategy.NO_LOAD && gFeature.getLoadStrategy() != LoadStrategy.GENOME) {
				enabled = true;
				break;
			}
		}

		if (refreshDataAction.isEnabled() != enabled) {
			refreshDataAction.setEnabled(enabled);
		}
	}

	private static boolean IsGenomeSequence() {
		BioSeq curSeq = gmodel.getSelectedSeq();
		final String seqID = curSeq == null ? null : curSeq.getID();
		return (seqID == null || IGBConstants.GENOME_SEQ_ID.equals(seqID));
	}

	public String getSelectedSpecies() {
		return (String) SeqGroupView.getInstance().getSpeciesCB().getSelectedItem();
	}

	public CThreadWorker<Void, Void> removeFeature(final GenericFeature feature, final boolean refresh) {
		if (feature == null) {
			return null;
		}

		CThreadWorker<Void, Void> delete = new CThreadWorker<Void, Void>("Removing feature  " + feature.featureName) {

			@Override
			protected Void runInBackground() {
				if (!feature.getMethods().isEmpty()) {
					for (BioSeq bioseq : feature.gVersion.group.getSeqList()) {
						for (String method : feature.getMethods()) {
							TrackView.deleteDependentData(gviewer.getSeqMap(), method, bioseq);
							TrackView.deleteSymsOnSeq(gviewer.getSeqMap(), method, bioseq, feature);
						}
					}
				}

				feature.clear();

				// If feature is local then remove it from server.
				GenericVersion version = feature.gVersion;
				if (version.gServer.serverType.equals(ServerType.LocalFiles)) {
					if (version.removeFeature(feature)) {
						SeqGroupView.getInstance().refreshTable();
						if (!gmodel.getSelectedSeqGroup().getSeqList().contains(gmodel.getSelectedSeq())) {
							gmodel.setSelectedSeq(gmodel.getSelectedSeqGroup().getSeqList().get(0));
						}
					}
				}

				return null;
			}

			@Override
			protected void finished() {
				if (refresh) {
					// Refresh
					refreshTreeView();
					createFeaturesTable();
					gviewer.dataRemoved();
				}
			}
		};

		ThreadUtils.getPrimaryExecutor(feature).execute(delete);

		return delete;
	}

	protected AbstractAction getRefreshDataAction() {
		return refreshDataAction;
	}

	@Override
	public boolean isEmbedded() {
		return true;
	}

	public static LoadModeDataTableModel getLoadModeTableModel() {
		if (loadModeDataTableModel != null) {
			return loadModeDataTableModel;
		}
		return null;
	}

	public FeatureTreeView getFeatureTree() {
		if (feature_tree_view != null) {
			return feature_tree_view;
		}
		return null;
	}
}
